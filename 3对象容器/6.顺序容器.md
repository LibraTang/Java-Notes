# 顺序容器
## 接口设计
假设我们现在要设计一个记事本，它应该有如下功能：

* `add(String note)` 添加记事
* `getSize()` 得知记事的数量
* `getNote(int index)` 获取指定记事
* `removeNote(int index)` 删除指定记事
* `list()` 列出当前记事本中的所有内容
上述被称为**接口设计**。

另外，我们平时写JAVA程序时，“计算”和“输入和输出”是在一起的。而在实际开发中，它们应该分开处理，也就是我们应该”专一“。
“计算”部分称为**业务逻辑**，“输入和输出”部分称为**人机交互**。我们现在只考虑“业务逻辑”部分。

我们要存储数据，可以用数组，但是数组的大小有限制，而我们的记事本是要加多少进去就应该存储多少，因此用数组不合适。在JAVA中，有一种东西叫**容器**，同样可以存放数据。

## 容器API

容器API的类图结构如下图所示：

![容器](https://github.com/LibraTang/Pics/blob/master/Java-Notes/%E5%AE%B9%E5%99%A81.png)

* Collection接口——定义了收取一组**对象**的方法，其子接口Set和List分别定义了存储方式
  * Set中的数据对象没有顺序且不可以重复
  * List中的数据对象有顺序且可以重复
* Map接口定义了存储“键（key）——值（value）映射对”的方法

### Collection方法举例

```java
import java.util.*;
public class Test {
    public static void main(String[] args) {
        Collection c = new ArrayList(); //父类引用指向子类对象，可以随时改变对象类型
        c.add("hello");
        c.add(new Name("f1", "11"));
        c.add(new Integer(100));
        System.out.println(c.size());
        System.out.println(c);
    }
}
```

**输出结果**：3

​		    [hello, f1 11, 100]

* 容器类对象在调用remove、contains等方法时需要比较对象是否相等，这会涉及到对象类型的equals方法和hashCode方法；对于自定义的类型，需要重写equals和hashCode方法以实现自定义的对象相等规则
  * 注意：相等的对象应该具有相等的hash codes

## Iterator接口

* 所有实现了Collection接口的容器类都有一个iterator方法用以返回一个实现了Iterator接口的对象
* Iterator对象称作迭代器，用以方便的实现对容器内元素的遍历操作
* Iterator接口定义了如下方法：
  * `boolean hasNext()`判断游标右边是否有元素
  * `Object next()`返回游标右边的元素并将游标移动到下一个位置
  * `void remove()`删除游标左面的元素，在执行完next后该操作只能执行一次

![Iterator接口](https://github.com/LibraTang/Pics/blob/master/Java-Notes/Iterator%E6%8E%A5%E5%8F%A3.png)

### Iterator方法举例

* Iterator对象的remove方法实在迭代过程中删除元素的唯一的安全方法

```java
Collection c = new HashSet();
c.add(new Name("fff1", "llll"));
c.add(new Name("f2", "l2"));
c.add(new Name("fff3", "lll3"));
for(Iterator i = c.iterator(); i.hasNext();) {
    Name name = (Name)i.next();
    if(name.getFirstName().length() < 3) {
        i.remove();
        //如果换成c.remove(name)；会产生例外
    }
}
System.out.println(c);
```

* **输出结果**：[fff3 lll3, fff1 llll]

## 泛型容器类
我们需要创造一个容器出来：
`public ArrayList<String> notes = new ArrayList<String>();`

**ArrayList**是一个类，叫做**顺序容器**。我们创造一个容器，要包括以下两点：

* 容器类型
* 元素类型

## ArrayList的操作
既然ArrayList是一个类，那么其中必有许多类函数可供我们使用，大大提高效率。如：

* `add(String)` 添加内容
* `add（index，String）` 在指定位置前插入内容
* `size()` 获取当前对象的大小
* `get(index)` 获取指定位置内容
* `remove(index)` 删除指定位置内容
* `toArray（String[] a)` 自动填写数据

## 完整程序：

```java
import java.util.ArrayList;

public class NoteBook {
	public ArrayList<String> notes = new ArrayList<String>();
	
	public void add(String s) {
		notes.add(s);
	}
	
	public void add(String s, int index) {
		notes.add(index, s);
	}
	
	public int getSize() {
		return notes.size();
	}
	
	public String getNote(int index) {
		return notes.get(index);
	}
	
	public void removeNote(int index) {
		notes.remove(index);
	}
	
	public String[] list() {
		String[] a = new String[notes.size()];
		notes.toArray(a);
		return a;
	}
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		NoteBook nb = new NoteBook();
		nb.add("First");
		nb.add("Seconds");
		System.out.println(nb.getSize());
		nb.add("Third", 1);
		nb.removeNote(1);
		String[] a = nb.list();
		for(String s:a) {
			System.out.println(s);
		}
	}

}
```
