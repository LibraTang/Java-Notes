> 以下源码基于JDK 11

## ArrayList

### 概览

* 实现了RandomAccess接口，因此支持随机访问（由于ArrayList是基于数组实现的因此必须支持随机）

```java
public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

* 数组默认大小为10

```java
private static final int DEFAULT_CAPACITY = 10;
```

### 扩容

添加元素时首先会检查数组容量，如果容量不够，回调用`grow()`方法扩容，扩容后容量为`oldCapacity + (oldCapacity >> 1)`，即为原容量的1.5倍。

扩容操作需要调用`Arrays.copyOf()`把原数组整个复制到新数组中，这个操作开销很大，因此最好在创建ArrayList的时候就指定大概的容量大小，以减少扩容的次数。

```java
public boolean add(E e) {
        modCount++;
        add(e, elementData, size);
        return true;
}

private void add(E e, Object[] elementData, int s) {
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1;
}

private Object[] grow() {
        return grow(size + 1);
}

private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData,
                                           newCapacity(minCapacity));
}

private int newCapacity(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
}
```

### 删除元素

需要调用`System.arraycpy()`方法将index+1后面的元素都复制到index位置上，因此该操作开销较大。

```java
public E remove(int index) { 
        Objects.checkIndex(index, size);
        final Object[] es = elementData;

        @SuppressWarnings("unchecked") E oldValue = (E) es[index];
        fastRemove(es, index);

        return oldValue;
}

private void fastRemove(Object[] es, int i) {
        modCount++;
        final int newSize;
        if ((newSize = size - 1) > i)
            System.arraycopy(es, i + 1, es, i, newSize - i);
        es[size = newSize] = null;
}
```

### Fail-Fast

`modCount`用来统计ArrayList结构发生变化的次数。结构发生变化指添加或删除一个元素，或调整内部数组大小，但仅仅是设置数组元素值不算结构发生变化。

在进行序列化或迭代等操作时，需要比较操作前后`modCount`是否发生变化，如果发生变化需要抛出`ConcurrentModificationException `异常

```java
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioral compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
}
```

### 序列化(?)

ArrayList基于数组实现，并且具有动态扩容的特性，因此保存元素的数组不一定都会用到，因此没必要全部序列化。

保存元素的数组elementData使用`transient`修饰，声明该数组默认不被序列化

```java
transient Object[] elementData; // non-private to simplify nested class access
```

ArrayList实现了`writeObject()`和`readObject()`来控制只序列化数组中有元素填充的部分

```java
private void writeObject(java.io.ObjectOutputStream s)
        throws java.io.IOException {
        // Write out element count, and any hidden stuff
        int expectedModCount = modCount;
        s.defaultWriteObject();

        // Write out size as capacity for behavioral compatibility with clone()
        s.writeInt(size);

        // Write out all elements in the proper order.
        for (int i=0; i<size; i++) {
            s.writeObject(elementData[i]);
        }

        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
}
```

```java
private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException {

        // Read in size, and any hidden stuff
        s.defaultReadObject();

        // Read in capacity
        s.readInt(); // ignored

        if (size > 0) {
            // like clone(), allocate array based upon size not capacity
            SharedSecrets.getJavaObjectInputStreamAccess().checkArray(s, Object[].class, size);
            Object[] elements = new Object[size];

            // Read in all elements in the proper order.
            for (int i = 0; i < size; i++) {
                elements[i] = s.readObject();
            }

            elementData = elements;
        } else if (size == 0) {
            elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new java.io.InvalidObjectException("Invalid size: " + size);
        }
    }
```

## Vector(不推荐使用)

Vector的实现与ArrayList类似，但是实现了`synchronized`同步

```java
public synchronized boolean add(E e) {
        modCount++;
        add(e, elementData, elementCount);
        return true;
}

public synchronized E get(int index) {
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return elementData(index);
}
```

* Vector使用`synchronized`进行同步，因此开销较大，访问速度慢，因此最好使用ArrayList，而同步操作完全可以由程序员自己控制。
* Vector每次扩容请求其原来2倍的空间
* 可以使用`Collection.synchronizedList()`得到一个线程安全的ArrayList

```java
List<String> list = new ArrayList<>();
List<String> synList = Collections.synchronizedList(list);
```

也可以使用concurrent并发包下的`CopyOnWriteArrayList`类

```java
public class CopyOnWriteArrayList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

## CopyOnWriteArrayList

### 读写分离

读操作在原始数组进行，写操作在复制出来的数组进行，写操作结束后再将原始数组指向新的复制数组。

写操作需要加锁，防止并发写入时数据丢失。

```java
public boolean add(E e) {
        synchronized (lock) {
            Object[] es = getArray();
            int len = es.length;
            es = Arrays.copyOf(es, len + 1);
            es[len] = e;
            setArray(es);
            return true;
        }
}

public E get(int index) {
        return elementAt(getArray(), index);
}

final Object[] getArray() {
        return array;
}

final void setArray(Object[] a) {
        array = a;
}
```

### 适用场景

`CopyOnWriteArrayList`适合读多写少的场景。

但是`CopyOnWriteArrayList`有缺陷：

* 在写操作时需要复制出一个新的数组，内存占用大
* 读操作不能读取实时数据，因为部分写操作的数据还未同步到读数组中

因此`CopyOnWriteArrayList`不适合内存敏感、对实时性要求高的场景。

## LinkedList

### 概览

基于双向链表实现，使用Node节点存储信息

```java
private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
}
```

每个链表存储了两个Node引用`first`和`last`指向首节点和尾节点

```java
transient Node<E> first;
transient Node<E> last;
```

链表的基本操作与C语言类似，以插入一个元素为例：

```java
private void linkFirst(E e) {
        final Node<E> f = first;
        final Node<E> newNode = new Node<>(null, e, f);
        first = newNode;
        if (f == null)
            last = newNode;
        else
            f.prev = newNode;
        size++;
        modCount++;
}

void linkLast(E e) {
        final Node<E> l = last;
        final Node<E> newNode = new Node<>(l, e, null);
        last = newNode;
        if (l == null)
            first = newNode;
        else
            l.next = newNode;
        size++;
        modCount++;
}

void linkBefore(E e, Node<E> succ) {
        // assert succ != null;
        final Node<E> pred = succ.prev;
        final Node<E> newNode = new Node<>(pred, e, succ);
        succ.prev = newNode;
        if (pred == null)
            first = newNode;
        else
            pred.next = newNode;
        size++;
        modCount++;
}
```

### 与ArrayList比较

* ArrayList基于动态数组实现，LinkedList基于双向链表实现
* ArrayList支持随机访问，LinkedList不支持
* LinkedList在任意位置添加删除元素更快

## HashMap

### 概述

HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，访问速度很快，但是遍历顺序不确定。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，如果需要满足线程安全，可以用Collections的synchronizedMap使HashMap具有线程安全能力，或者使用ConcurrentHashMap。

### 结构实现

HashMap是数组＋链表＋红黑树（JDK1.8增加了红黑树）实现

![HashMap结构](https://github.com/LibraTang/Pics/blob/master/Java-Notes/hashMap%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE.png)

HashMap用Node数组存储元素，即哈希桶数组，实现了`Map.Entry`接口，本质是一个映射。上图中每个黑点就是一个Node对象。

```java
transient Node<K,V>[] table;

static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry<?,?> e = (Map.Entry<?,?>)o;
                if (Objects.equals(key, e.getKey()) &&
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
```

HashMap使用哈希表存储。为解决冲突，HashMap采用了链地址法，即每一个数组元素上都存储了一个链表，当数据被hash后，得到数组下标，把数据放在对应下标的链表上（JDK1.7之前是头插，JDK1.8之后是尾插）。

如果哈希桶数组很大，虽然数据分散了不容易碰撞，但是浪费空间；如果哈希桶数组很小，数据容易发生碰撞。因此一个好的hash算法和扩容机制能够权衡空间成本和时间成本。

先了解下HashMap的几个字段：

```java
transient int size;
transient int modCount;
int threshold; //能容纳的最大Node个数
final float loadFactor; //负载因子
```

Node[] table的初始length为16，loadFactor为负载因子，默认为0.75，threshold为HashMap所能容纳的最大数据量的Node（键值对）个数，threshold=length*loadFactor。size为HashMap中实际存在的键值对数量（区分threshold）。modCount字段用来记录HashMap结构发生变化的次数(ArrayList部分已讲过)。

若需要空间超过threshold就扩容resize，扩容后的HashMap容量是原来的2倍。默认的负载因子0.75是对空间和时间效率的一个平衡，因此不要随便修改。

在HashMap中，哈希桶数组table的长度length必须为2的n次方，主要是为了在取模和扩容时做优化，同时为了减少冲突，而做出的规范。（若用户传入的length不是2的n次方，HashMap也会自动将传入的length转换为2的n次方）

即使负载因子和hash算法设计的再合理，也免不了拉链过长的情况，会严重影响HashMap的性能。因此在JDK1.8中引入了红黑树，当链表长度超过8时，链表转换为红黑树。

### 功能实现

#### 确定哈希桶数组索引位置(?)

不管是增加、删除还是查找键值对，确定哈希桶数组的位置都是很关键的。我们希望这个HashMap里面元素的位置尽量分布均匀，最好每个位置上只有一个元素，这样当我们用hash方法求得这个位置时可以直接得到值，而不用去遍历链表。

```java
static final int hash(Object key) { //JDK11
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

```java
final int hash(Object k) { //JDK7
        int h = hashSeed;
        if (0 != h && k instanceof String) {
            return sun.misc.Hashing.stringHash32((String) k);
        }

        h ^= k.hashCode(); //取hashCode值

        // This function ensures that hashCodes that differ only by
        // constant multiples at each bit position have a bounded
        // number of collisions (approximately 8 at default load factor).
        h ^= (h >>> 20) ^ (h >>> 12); //高位参与运算
        return h ^ (h >>> 7) ^ (h >>> 4);
    }

    /**
     * Returns index for hash code h.
     */
    static int indexFor(int h, int length) {
        // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";
        return h & (length - 1); //取模运算
    }
```

hash算法本质就三步：**取key的hashCode，高位运算，取模运算**

