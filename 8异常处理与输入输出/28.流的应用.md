# 流的应用

现在已经很少用流的方式对文件进行操作。

可以用`socket`来建立本地与服务器间文本的联系:
```````````````java
public static void main(String[] args){
	try{
		Socket socket = new Socket(InetAddress.getByName("localhost"),12345);
		PrintWriter out = new PrintWriter(
			new BufferedWriter(
				new OutputStreamWriter(
					socket.getOutputStream())));
		out.println("Hello");
		BufferedRead in = new BufferedReader(
			new InputStreamReader(
				socket.getInputStream()));
		String line;
		line = in.readline();
		System.out.println(line);
		out.close();
		socket.close();
	}catch(IOException e){
		e.printStackTrace();
	}
`````````````````

（图片迟到……）

## 对象串行化

怎样将类的对象写到文件中并输出？

（图片迟到……）

`````````````java
class Student implements Serializable{
	private String name;
	private int age;
	private int grade;
	
public Student(String name, int age, int grade){
	this.name = name;
	this.age = age;
	this.grade = grade;
}

public String toString(){
	return name + "" + age + "" + grade;
	}
}

public class Main{
	public static void main(String [] args){
		try{
			Student s1 = new Student("John",18,5);
			System.out.println(s1);
			ObjectOutputStream out = new ObjectOutputStream(
				new FileOutputStream("obj.dat"));
			out.writeObject(s1);
			out.close();
			ObjectInputStream in = new ObjectInputStream(
				new FileInputStream("obj.dat"));
			Student s2 = (Student)in.readObject();
			System.out.println(s2);
			in.close();
		}catch(IOException e){
			e.printStackTrace();
		}catch(ClassNotFoundException e){
			e.printStackTrace();
	}
```````````

注意，在这个程序里，**s1和s2是两个不同的对象，只是内容相同**。这说明当我们反串行化构造出一个对象时，这个对象和之前写进去的对象是不一样的，但是值一样。



